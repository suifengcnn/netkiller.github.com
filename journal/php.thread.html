<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PHP 高级编程之多线程</title><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="/journal/journal.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><meta name="description" content="2014-03-12 第一版 2014-05-15 第二版 2014-06-13 第三版 2014-07-24 第四版 2015-10-26 第五版"/><meta name="keywords" content="PHP线程池, PHP多线程, PHP多进程, php pathreads, zeromq, "/></head><body><section xml:lang="zh-cn" class="article" id="idp1"><div class="titlepage"><div><div><h2 class="title">PHP 高级编程之多线程</h2></div><div><h3 class="subtitle"><em>http://netkiller.github.io/journal/php.thread.html</em></h3></div><div><div class="author"><h3 class="author"><span class="honorific">Mr</span>. <span class="firstname">Neo Chen</span> <span class="surname">(陈景峯)</span>, <span class="lineage">netkiller, BG7NYT</span></h3><div class="affiliation"><div class="address"><p><br/>
				<span class="country">中国</span><span class="state">广东省</span><span class="city">深圳市</span><span class="street">龙华新区民治街道溪山美地</span><br/>
				<span class="postcode">518131</span><br/>
				<span class="phone">+86 13113668890</span><br/>
				<br/>
				<code class="email">&lt;<a class="email" href="mailto:netkiller@msn.com">netkiller@msn.com</a>&gt;</code><br/>
			</p></div></div></div></div><div><div class="legalnotice" id="legalnotice"><p class="legalnotice-title"><strong>版权声明</strong></p><p>转载请与作者联系，转载时请务必标明文章原始出处和作者信息及本声明。</p><table style="border: 0; " class="simplelist"><tr><td>
		<a class="ulink" href="http://creativecommons.org/licenses/by/3.0/" target="_top">
			<div><table style="border: 0; width: 180px; cellpadding: 0; cellspacing: 0;"><tr><td><img src="/images/by-nc-sa.png" width="180"/></td></tr></table></div>
		</a>
		</td><td>
			<table style="border: 0; " class="simplelist"><tr><td>
					文档出处:
				</td></tr><tr><td>
					<a class="ulink" href="http://netkiller.github.io/" target="_top">http://netkiller.github.io</a>
				</td></tr><tr><td>
					<a class="ulink" href="http://netkiller.sourceforge.net/" target="_top">http://netkiller.sourceforge.net</a>
				</td></tr></table>
		</td><td>
			<a class="ulink" href="/images/weixin.jpg" target="_top"><div><table style="border: 0; width: 80px; cellpadding: 0; cellspacing: 0;"><tr><td><img src="/images/weixin.jpg" width="80"/></td></tr></table></div></a>
		</td><td>
			<p>微信扫描二维码进入 Netkiller 微信订阅号 </p>
			<p>QQ群：128659835 请注明“读者”</p>
		</td></tr></table><p/></div></div><div><p class="pubdate">2017-06-16</p></div><div><div class="abstract"><div class="abstract-title">摘要</div>
			<p>2014-03-12 第一版</p>
			<p>2014-05-15 第二版</p>
			<p>2014-06-13 第三版</p>
			<p>2014-07-24 第四版</p>
			<p>2015-10-26 第五版</p>
		</div></div></div><hr/></div><div class="toc"><div class="toc-title">目录</div><ul class="toc"><li><span class="section"><a href="#install">1. 多线程环境安装</a></span><ul><li><span class="section"><a href="#idp2">1.1. PHP 5.5.9</a></span></li><li><span class="section"><a href="#idp3">1.2. 安装 pthreads 扩展</a></span></li></ul></li><li><span class="section"><a href="#thread">2. Thread</a></span></li><li><span class="section"><a href="#worker">3. Worker 与 Stackable</a></span></li><li><span class="section"><a href="#mutex">4. 互斥锁</a></span><ul><li><span class="section"><a href="#idp4">4.1. 多线程与共享内存</a></span></li></ul></li><li><span class="section"><a href="#synchronized">5. 线程同步</a></span></li><li><span class="section"><a href="#pool">6. 线程池</a></span><ul><li><span class="section"><a href="#idp5">6.1. pthreads Pool类</a></span></li><li><span class="section"><a href="#idp6">6.2. 线程池的原理</a></span></li><li><span class="section"><a href="#idp7">6.3. 动态队列线程池</a></span></li><li><span class="section"><a href="#idp8">6.4. 等待线程池中的线程运行完毕</a></span></li></ul></li><li><span class="section"><a href="#filelock">7. 多线程文件安全读写（文件锁）</a></span></li><li><span class="section"><a href="#db">8. 多线程与数据连接</a></span><ul><li><span class="section"><a href="#idp9">8.1. Worker 与 PDO</a></span></li><li><span class="section"><a href="#idp10">8.2. Pool 与 PDO</a></span></li><li><span class="section"><a href="#idp11">8.3. 数据库持久连接</a></span></li><li><span class="section"><a href="#idp12">8.4. 涉及数据库更新</a></span></li></ul></li><li><span class="section"><a href="#zero">9. Thread And ZeroMQ</a></span><ul><li><span class="section"><a href="#idp13">9.1. 数据库端</a></span></li><li><span class="section"><a href="#idp14">9.2. 数据处理端</a></span></li></ul></li><li><span class="section"><a href="#idp15">10. 延伸阅读</a></span></li></ul></div>
	

	<section class="section" id="install"><div class="titlepage"><div><div><h2 class="title" style="clear: both">1. 多线程环境安装</h2></div></div></div>
		
		<section class="section" id="idp2"><div class="titlepage"><div><div><h3 class="title">1.1. PHP 5.5.9</h3></div></div></div>
			
			<p>安装PHP 5.5.9</p>
			<p>https://github.com/oscm/shell/blob/master/php/5.5.9.sh</p>
			<pre class="screen">
./configure --prefix=/srv/php-5.5.9 \
--with-config-file-path=/srv/php-5.5.9/etc \
--with-config-file-scan-dir=/srv/php-5.5.9/etc/conf.d \
--enable-fpm \
--with-fpm-user=www \
--with-fpm-group=www \
--with-pear \
--with-curl \
--with-gd \
--with-jpeg-dir \
--with-png-dir \
--with-freetype-dir \
--with-zlib-dir \
--with-iconv \
--with-mcrypt \
--with-mhash \
--with-pdo-mysql \
--with-mysql-sock=/var/lib/mysql/mysql.sock \
--with-openssl \
--with-xsl \
--with-recode \
--enable-sockets \
--enable-soap \
--enable-mbstring \
--enable-gd-native-ttf \
--enable-zip \
--enable-xml \
--enable-bcmath \
--enable-calendar \
--enable-shmop \
--enable-dba \
--enable-wddx \
--enable-sysvsem \
--enable-sysvshm \
--enable-sysvmsg \
--enable-opcache \
--enable-pcntl \
--enable-maintainer-zts \
--disable-debug
			</pre>
			<p>编译必须启用zts支持否则无法安装 pthreads(--enable-maintainer-zts)</p>
		</section>
		<section class="section" id="idp3"><div class="titlepage"><div><div><h3 class="title">1.2. 安装 pthreads 扩展</h3></div></div></div>
			
			<p>安装https://github.com/oscm/shell/blob/master/php/pecl/pthreads.sh</p>
			<pre class="screen">
# curl -s https://raw.github.com/oscm/shell/master/php/pecl/pthreads.sh | bash
			</pre>
			<p>查看pthreads是否已经安装</p>
			<pre class="screen">
# php -m | grep pthreads
			</pre>
		</section>
	</section>
	<section class="section" id="thread"><div class="titlepage"><div><div><h2 class="title" style="clear: both">2. Thread</h2></div></div></div>
		
		<pre class="programlisting">
		
&lt;?php
class HelloWorld extends Thread {
    public function __construct($world) {
       $this-&gt;world = $world;
    }

    public function run() {
        print_r(sprintf("Hello %s\n", $this-&gt;world));
    }
}

$thread = new HelloWorld("World");

if ($thread-&gt;start()) {
    printf("Thread #%lu says: %s\n", $thread-&gt;getThreadId(), $thread-&gt;join());
}
?&gt;
		
		</pre>
	</section>
	<section class="section" id="worker"><div class="titlepage"><div><div><h2 class="title" style="clear: both">3. Worker 与 Stackable</h2></div></div></div>
		
		<pre class="programlisting">
		
&lt;?php
class SQLQuery extends Stackable {

        public function __construct($sql) {
                $this-&gt;sql = $sql;
        }

        public function run() {
                $dbh  = $this-&gt;worker-&gt;getConnection();
                $row = $dbh-&gt;query($this-&gt;sql);
                while($member = $row-&gt;fetch(PDO::FETCH_ASSOC)){
                        print_r($member);
                }
        }

}

class ExampleWorker extends Worker {
        public static $dbh;
        public function __construct($name) {
        }

        /*
        * The run method should just prepare the environment for the work that is coming ...
        */
        public function run(){
                self::$dbh = new PDO('mysql:host=192.168.2.1;dbname=example','www','123456');
        }
        public function getConnection(){
                return self::$dbh;
        }
}

$worker = new ExampleWorker("My Worker Thread");

$work=new SQLQuery('select * from members order by id desc limit 5');
$worker-&gt;stack($work);

$table1 = new SQLQuery('select * from demousers limit 2');
$worker-&gt;stack($table1);

$worker-&gt;start();
$worker-&gt;shutdown();
?&gt;
		
		</pre>
	</section>
	<section class="section" id="mutex"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4. 互斥锁</h2></div></div></div>
		
		<p>什么情况下会用到互斥锁？在你需要控制多个线程同一时刻只能有一个线程工作的情况下可以使用。</p>
		<p>下面我们举一个例子，一个简单的计数器程序，说明有无互斥锁情况下的不同。</p>
		<pre class="programlisting">
		
&lt;?php
$counter = 0;
//$handle=fopen("php://memory", "rw");
//$handle=fopen("php://temp", "rw");
$handle=fopen("/tmp/counter.txt", "w");
fwrite($handle, $counter );
fclose($handle);

class CounterThread extends Thread {
	public function __construct($mutex = null){
		$this-&gt;mutex = $mutex;
        $this-&gt;handle = fopen("/tmp/counter.txt", "w+");
    }
	public function __destruct(){
		fclose($this-&gt;handle);
	}
    public function run() {
		if($this-&gt;mutex)
			$locked=Mutex::lock($this-&gt;mutex);

		$counter = intval(fgets($this-&gt;handle));
		$counter++;
		rewind($this-&gt;handle);
		fputs($this-&gt;handle, $counter );
		printf("Thread #%lu says: %s\n", $this-&gt;getThreadId(),$counter);

		if($this-&gt;mutex)
			Mutex::unlock($this-&gt;mutex);
    }
}

//没有互斥锁
for ($i=0;$i&lt;50;$i++){
	$threads[$i] = new CounterThread();
	$threads[$i]-&gt;start();

}

//加入互斥锁
$mutex = Mutex::create(true);
for ($i=0;$i&lt;50;$i++){
	$threads[$i] = new CounterThread($mutex);
	$threads[$i]-&gt;start();

}

Mutex::unlock($mutex);
for ($i=0;$i&lt;50;$i++){
	$threads[$i]-&gt;join();
}
Mutex::destroy($mutex);

?&gt;
		
		</pre>
		<p>我们使用文件/tmp/counter.txt保存计数器值，每次打开该文件将数值加一，然后写回文件。当多个线程同时操作一个文件的时候，就会线程运行先后取到的数值不同，写回的数值也不同，最终计数器的数值会混乱。</p>
		<p>没有加入锁的结果是计数始终被覆盖，最终结果是2</p>
		<p>而加入互斥锁后，只有其中的一个进程完成加一工作并释放锁，其他线程才能得到解锁信号，最终顺利完成计数器累加操作</p>
		<p>上面例子也可以通过对文件加锁实现，这里主要讲的是多线程锁，后面会涉及文件锁。</p>
		<section class="section" id="idp4"><div class="titlepage"><div><div><h3 class="title">4.1. 多线程与共享内存</h3></div></div></div>
			
			<p>在共享内存的例子中，没有使用任何锁，仍然可能正常工作，可能工作内存操作本身具备锁的功能。</p>
			<pre class="programlisting">
			
&lt;?php
$tmp = tempnam(__FILE__, 'PHP');
$key = ftok($tmp, 'a');

$shmid = shm_attach($key);
$counter = 0;
shm_put_var( $shmid, 1, $counter );

class CounterThread extends Thread {
	public function __construct($shmid){
        $this-&gt;shmid = $shmid;
    }
    public function run() {

		$counter = shm_get_var( $this-&gt;shmid, 1 );
		$counter++;
		shm_put_var( $this-&gt;shmid, 1, $counter );

		printf("Thread #%lu says: %s\n", $this-&gt;getThreadId(),$counter);
    }
}

for ($i=0;$i&lt;100;$i++){
	$threads[] = new CounterThread($shmid);
}
for ($i=0;$i&lt;100;$i++){
	$threads[$i]-&gt;start();

}

for ($i=0;$i&lt;100;$i++){
	$threads[$i]-&gt;join();
}
shm_remove( $shmid );
shm_detach( $shmid );
?&gt;
			
			</pre>
		</section>
	</section>
	<section class="section" id="synchronized"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5. 线程同步</h2></div></div></div>
		
		<p>有些场景我们不希望  thread-&gt;start() 就开始运行程序，而是希望线程等待我们的命令。</p>
		<p>$thread-&gt;wait();测作用是 thread-&gt;start()后线程并不会立即运行，只有收到 $thread-&gt;notify(); 发出的信号后才运行 </p>

		<pre class="programlisting">
		
&lt;?php
$tmp = tempnam(__FILE__, 'PHP');
$key = ftok($tmp, 'a');

$shmid = shm_attach($key);
$counter = 0;
shm_put_var( $shmid, 1, $counter );

class CounterThread extends Thread {
	public function __construct($shmid){
        $this-&gt;shmid = $shmid;
    }
    public function run() {

        $this-&gt;synchronized(function($thread){
            $thread-&gt;wait();
        }, $this);

		$counter = shm_get_var( $this-&gt;shmid, 1 );
		$counter++;
		shm_put_var( $this-&gt;shmid, 1, $counter );

		printf("Thread #%lu says: %s\n", $this-&gt;getThreadId(),$counter);
    }
}

for ($i=0;$i&lt;100;$i++){
	$threads[] = new CounterThread($shmid);
}
for ($i=0;$i&lt;100;$i++){
	$threads[$i]-&gt;start();

}

for ($i=0;$i&lt;100;$i++){
	$threads[$i]-&gt;synchronized(function($thread){
		$thread-&gt;notify();
	}, $threads[$i]);
}

for ($i=0;$i&lt;100;$i++){
	$threads[$i]-&gt;join();
}
shm_remove( $shmid );
shm_detach( $shmid );
?&gt;
		
		</pre>
	</section>
	<section class="section" id="pool"><div class="titlepage"><div><div><h2 class="title" style="clear: both">6. 线程池</h2></div></div></div>
		
		<section class="section" id="idp5"><div class="titlepage"><div><div><h3 class="title">6.1. pthreads Pool类</h3></div></div></div>
			
			<p>pthreads 提供的 Pool class 例子</p>
			<pre class="programlisting">
			
&lt;?php

class WebWorker extends Worker {

	public function __construct(SafeLog $logger) {
		$this-&gt;logger = $logger;
	}

	protected $loger;
}

class WebWork extends Stackable {

	public function isComplete() {
		return $this-&gt;complete;
	}

	public function run() {
		$this-&gt;worker
			-&gt;logger
			-&gt;log("%s executing in Thread #%lu",
				  __CLASS__, $this-&gt;worker-&gt;getThreadId());
		$this-&gt;complete = true;
	}

	protected $complete;
}

class SafeLog extends Stackable {

	protected function log($message, $args = []) {
		$args = func_get_args();

		if (($message = array_shift($args))) {
			echo vsprintf(
				"{$message}\n", $args);
		}
	}
}


$pool = new Pool(8, \WebWorker::class, [new SafeLog()]);

$pool-&gt;submit($w=new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;submit(new WebWork());
$pool-&gt;shutdown();

$pool-&gt;collect(function($work){
	return $work-&gt;isComplete();
});

var_dump($pool);
			
			</pre>
			<p>现在我来详细讲解线程池，官方文档比较少，很多经验是笔者工作中摸索出来的。</p>
			<p>Pool 构造方法第一次参数 size, 手册解释是 Pool 对象可容纳的 Worker 对象的最大数量，但我实际使用发现 size 并不是控制pool压入任务的数量，而是同时并发的线程数。</p>
			<p>$pool-&gt;submit()是可以无线提交任务的，只要内存允许（参考php.ini配置），但同时执行的线程数由size控制。</p>
		</section>		
		<section class="section" id="idp6"><div class="titlepage"><div><div><h3 class="title">6.2. 线程池的原理</h3></div></div></div>
			
			<p>我们自行实现一个类来解释Pool工作原理</p>
			<pre class="programlisting">
			
&lt;?php
class Update extends Thread {

    public $running = false;
    public $row = array();
    public function __construct($row) {

	$this-&gt;row = $row;
        $this-&gt;sql = null;
    }

    public function run() {

	if(strlen($this-&gt;row['bankno']) &gt; 100 ){
		$bankno = safenet_decrypt($this-&gt;row['bankno']);
	}else{
		$error = sprintf("%s, %s\r\n",$this-&gt;row['id'], $this-&gt;row['bankno']);
		file_put_contents("bankno_error.log", $error, FILE_APPEND);
	}

	if( strlen($bankno) &gt; 7 ){
		$sql = sprintf("update members set bankno = '%s' where id = '%s';", $bankno, $this-&gt;row['id']);

		$this-&gt;sql = $sql;
	}

	printf("%s\n",$this-&gt;sql);
    }

}

class Pool {
	public $pool = array();
	public function __construct($count) {
		$this-&gt;count = $count;
	}
	public function push($row){
		if(count($this-&gt;pool) &lt; $this-&gt;count){
			$this-&gt;pool[] = new Update($row);
			return true;
		}else{
			return false;
		}
	}
	public function start(){
		foreach ( $this-&gt;pool as $id =&gt; $worker){
			$this-&gt;pool[$id]-&gt;start();
		}
	}
	public function join(){
		foreach ( $this-&gt;pool as $id =&gt; $worker){
               $this-&gt;pool[$id]-&gt;join();
		}
	}
	public function clean(){
		foreach ( $this-&gt;pool as $id =&gt; $worker){
			if(! $worker-&gt;isRunning()){
            	unset($this-&gt;pool[$id]);
            }
		}
	}
}

try {
	$dbh    = new PDO("mysql:host=" . str_replace(':', ';port=', $dbhost) . ";dbname=$dbname", $dbuser, $dbpw, array(
		PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
		PDO::MYSQL_ATTR_COMPRESS =&gt; true
		)
	);

	$sql  = "select id,bankno from members order by id desc";
	$row = $dbh-&gt;query($sql);
	$pool = new Pool(5);
	while($member = $row-&gt;fetch(PDO::FETCH_ASSOC))
	{

		while(true){
			if($pool-&gt;push($member)){ //压入任务到池中
				break;
			}else{ //如果池已经满，就开始启动线程
				$pool-&gt;start();
				$pool-&gt;join();
				$pool-&gt;clean();
			}
		}
	}
	$pool-&gt;start();
    $pool-&gt;join();

	$dbh = null;

} catch (Exception $e) {
    echo '[' , date('H:i:s') , ']', '系统错误', $e-&gt;getMessage(), "\n";
}
?&gt;
			
			</pre>
		</section>
		<section class="section" id="idp7"><div class="titlepage"><div><div><h3 class="title">6.3. 动态队列线程池</h3></div></div></div>
			
			<p>上面的例子是当线程池满后执行start统一启动，下面的例子是只要线程池中有空闲便立即创建新线程。</p>
			<pre class="programlisting">
			
&lt;?php
class Update extends Thread {

    public $running = false;
    public $row = array();
    public function __construct($row) {

	$this-&gt;row = $row;
        $this-&gt;sql = null;
	//print_r($this-&gt;row);
    }

    public function run() {

	if(strlen($this-&gt;row['bankno']) &gt; 100 ){
		$bankno = safenet_decrypt($this-&gt;row['bankno']);
	}else{
		$error = sprintf("%s, %s\r\n",$this-&gt;row['id'], $this-&gt;row['bankno']);
		file_put_contents("bankno_error.log", $error, FILE_APPEND);
	}

	if( strlen($bankno) &gt; 7 ){
		$sql = sprintf("update members set bankno = '%s' where id = '%s';", $bankno, $this-&gt;row['id']);

		$this-&gt;sql = $sql;
	}

	printf("%s\n",$this-&gt;sql);
    }

}



try {
	$dbh    = new PDO("mysql:host=" . str_replace(':', ';port=', $dbhost) . ";dbname=$dbname", $dbuser, $dbpw, array(
		PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
		PDO::MYSQL_ATTR_COMPRESS =&gt; true
		)
	);

	$sql     = "select id,bankno from members order by id desc limit 50";

	$row = $dbh-&gt;query($sql);
	$pool = array();
	while($member = $row-&gt;fetch(PDO::FETCH_ASSOC))
	{
		$id 	= $member['id'];
		while (true){
			if(count($pool) &lt; 5){
				$pool[$id] = new Update($member);
				$pool[$id]-&gt;start();
				break;
			}else{
				foreach ( $pool as $name =&gt; $worker){
					if(! $worker-&gt;isRunning()){
						unset($pool[$name]);
					}
				}
			}
		}

	}

	$dbh = null;

} catch (Exception $e) {
    echo '【' , date('H:i:s') , '】', '【系统错误】', $e-&gt;getMessage(), "\n";
}
?&gt;
			
			</pre>
		</section>
		<section class="section" id="idp8"><div class="titlepage"><div><div><h3 class="title">6.4. 等待线程池中的线程运行完毕</h3></div></div></div>
			
			<p> $pool-&gt;submit 是非阻塞，提交到线程池中，就会运行下面代码，有时我们希望等待线程执行完毕，收集线程的工作状况。</p>
			<pre class="programlisting">
			
		$mutex = Mutex::create();
		$pool = new Pool ( self::MAXCONN , \ImportWorker::class, array($this-&gt;config, $mutex) );
		
		$pool-&gt;collect(function($work){
				return $work-&gt;isComplete();
			});
		
		foreach($tasks as $task){
			$this-&gt;logger ( __CLASS__, sprintf("Task %s %s", $task-&gt;file, 'Processing') );

			pcntl_signal_dispatch();
			
			if(Signal::get() == SIGHUP){
				Signal::reset();
				break;
			}
			
			if(file_exists ($task-&gt;file)){

				$handle = fopen($task-&gt;file, 'r');
				$i = 0;
				while (($row = fgetcsv($handle, 100000, ',')) !== false) {
					$work[$i] =  new Import ( $task, $row );
					$pool-&gt;submit ( $work[$i] );
					$i++;
					//$pool-&gt;submit ( new Import ( $task, $row ));

				}
		
				fclose($handle);
				
				$waiting = true;
				while($waiting){
					
					for($i=0;$i&lt;count($work);$i++){
						
						if($work[$i]-&gt;isComplete()){
							Counter::$completed++;
						}
						//printf("work %s:%s \n", count($work), Counter::$completed);
						if(Counter::$completed == count($work)){
							$waiting = false;
							break;
						}
					}
					sleep(1);
				}

				$this-&gt;completedTask($task);
			}else{
				$this-&gt;failedTask($task);
			}
			//printf("Ignore: %s\n", Counter::$ignore ) ;
		}
		
		$pool-&gt;shutdown ();

		//Mutex::unlock($mutex);
		Mutex::destroy($mutex);			
			
			</pre>
			<p>while($waiting) 对持续运行，直到所有线程都完成后才会退出。</p>
		</section>
	</section>
	<section class="section" id="filelock"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7. 多线程文件安全读写（文件锁）</h2></div></div></div>
		
		<p>在多线程中读写文件但进程是有区别的，读取内容比较容易时间，但写入数据就需要保证同一时刻只能有一个进程操作，虽然通过互斥锁可以解决，但从安全的角度文件必须上锁。</p>
		<p>文件锁种类。</p>
		<pre class="screen">
LOCK_SH 取得共享锁定（读取的程序）。
LOCK_EX 取得独占锁定（写入的程序。
LOCK_UN 释放锁定（无论共享或独占）。
LOCK_NB 如果不希望 flock() 在锁定时堵塞
		</pre>
		<p>共享锁例子</p>
		<pre class="programlisting">
		
&lt;?php

$fp = fopen("/tmp/lock.txt", "r+");

if (flock($fp, LOCK_EX)) {  // 进行排它型锁定
    ftruncate($fp, 0);      // truncate file
    fwrite($fp, "Write something here\n");
    fflush($fp);            // flush output before releasing the lock
    flock($fp, LOCK_UN);    // 释放锁定
} else {
    echo "Couldn't get the lock!";
}

fclose($fp);

?&gt;
		
		</pre>
		<p>共享锁例子2</p>
		<pre class="programlisting">
		
&lt;?php
$fp = fopen('/tmp/lock.txt', 'r+');

/* Activate the LOCK_NB option on an LOCK_EX operation */
if(!flock($fp, LOCK_EX | LOCK_NB)) {
    echo 'Unable to obtain lock';
    exit(-1);
}

/* ... */

fclose($fp);
?&gt;
		
		</pre>

	</section>
	<section class="section" id="db"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8. 多线程与数据连接</h2></div></div></div>
		
		<p>多线程中操作数据库总结与注意事项 pthreads 与 pdo 同时使用是，需要注意一点，需要静态声明public static $dbh;并且通过单例模式访问数据库连接。</p>
		<section class="section" id="idp9"><div class="titlepage"><div><div><h3 class="title">8.1. Worker 与 PDO</h3></div></div></div>
			
			<pre class="programlisting">
			
&lt;?php
class Work extends Stackable {

        public function __construct() {
        }

        public function run() {
                $dbh  = $this-&gt;worker-&gt;getConnection();
                $sql     = "select id,name from members order by id desc limit 50";
                $row = $dbh-&gt;query($sql);
                while($member = $row-&gt;fetch(PDO::FETCH_ASSOC)){
                        print_r($member);
                }
        }

}

class ExampleWorker extends Worker {
        public static $dbh;
        public function __construct($name) {
        }

        /*
        * The run method should just prepare the environment for the work that is coming ...
        */
        public function run(){
                self::$dbh = new PDO('mysql:host=192.168.2.1;dbname=example','www','123456');
        }
        public function getConnection(){
                return self::$dbh;
        }
}

$worker = new ExampleWorker("My Worker Thread");

$work=new Work();
$worker-&gt;stack($work);

$worker-&gt;start();
$worker-&gt;shutdown();
?&gt;
			
			</pre>
		</section>
		<section class="section" id="idp10"><div class="titlepage"><div><div><h3 class="title">8.2. Pool 与 PDO</h3></div></div></div>
			
			<p>在线程池中链接数据库</p>
			<pre class="programlisting">
			
# cat pool.php
&lt;?php
class ExampleWorker extends Worker {

	public function __construct(Logging $logger) {
		$this-&gt;logger = $logger;
	}

	protected $logger;
}

/* the collectable class implements machinery for Pool::collect */
class Work extends Stackable {
	public function __construct($number) {
		$this-&gt;number = $number;
	}
	public function run() {
                $dbhost = 'db.example.com';               // 数据库服务器
                $dbuser = 'example.com';                 // 数据库用户名
                $dbpw = 'password';                               // 数据库密码
                $dbname = 'example_real';
		$dbh  = new PDO("mysql:host=$dbhost;port=3306;dbname=$dbname", $dbuser, $dbpw, array(
                        PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
                        PDO::MYSQL_ATTR_COMPRESS =&gt; true,
			PDO::ATTR_PERSISTENT =&gt; true
                        )
                );
		$sql = "select OPEN_TIME, `COMMENT` from MT4_TRADES where LOGIN='".$this-&gt;number['name']."' and CMD='6' and `COMMENT` = '".$this-&gt;number['order'].":DEPOSIT'";
		#echo $sql;
		$row = $dbh-&gt;query($sql);
		$mt4_trades  = $row-&gt;fetch(PDO::FETCH_ASSOC);
		if($mt4_trades){

			$row = null;

			$sql = "UPDATE db_example.accounts SET paystatus='成功', deposit_time='".$mt4_trades['OPEN_TIME']."' where `order` = '".$this-&gt;number['order']."';";
			$dbh-&gt;query($sql);
			#printf("%s\n",$sql);
		}
		$dbh = null;
		printf("runtime: %s, %s, %s\n", date('Y-m-d H:i:s'), $this-&gt;worker-&gt;getThreadId() ,$this-&gt;number['order']);

	}
}

class Logging extends Stackable {
	protected  static $dbh;
	public function __construct() {
		$dbhost = 'db.example.com';			// 数据库服务器
	        $dbuser = 'example.com';                 // 数据库用户名
        	$dbpw = 'password';                               // 数据库密码
		$dbname = 'example_real';			// 数据库名

		self::$dbh  = new PDO("mysql:host=$dbhost;port=3306;dbname=$dbname", $dbuser, $dbpw, array(
			PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
			PDO::MYSQL_ATTR_COMPRESS =&gt; true
			)
		);

	}
	protected function log($message, $args = []) {
		$args = func_get_args();

		if (($message = array_shift($args))) {
			echo vsprintf("{$message}\n", $args);
		}
	}

	protected function getConnection(){
                return self::$dbh;
        }
}

$pool = new Pool(200, \ExampleWorker::class, [new Logging()]);

$dbhost = 'db.example.com';                      // 数据库服务器
$dbuser = 'example.com';                 // 数据库用户名
$dbpw = 'password';                               // 数据库密码
$dbname = 'db_example';
$dbh    = new PDO("mysql:host=$dbhost;port=3306;dbname=$dbname", $dbuser, $dbpw, array(
                        PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
                        PDO::MYSQL_ATTR_COMPRESS =&gt; true
                        )
                );
$sql = "select `order`,name from accounts where deposit_time is null order by id desc";

$row = $dbh-&gt;query($sql);
while($account = $row-&gt;fetch(PDO::FETCH_ASSOC))
{
        $pool-&gt;submit(new Work($account));
}

$pool-&gt;shutdown();

?&gt;
			
			</pre>
			<p>进一步改进上面程序，我们使用单例模式 $this-&gt;worker-&gt;getInstance(); 全局仅仅做一次数据库连接，线程使用共享的数据库连接</p>
			<pre class="programlisting">
			
&lt;?php
class ExampleWorker extends Worker {

	#public function __construct(Logging $logger) {
	#	$this-&gt;logger = $logger;
	#}

	#protected $logger;
	protected  static $dbh;
	public function __construct() {

	}
	public function run(){
		$dbhost = 'db.example.com';			// 数据库服务器
	    $dbuser = 'example.com';        	// 数据库用户名
        $dbpw = 'password';             	// 数据库密码
		$dbname = 'example';				// 数据库名

		self::$dbh  = new PDO("mysql:host=$dbhost;port=3306;dbname=$dbname", $dbuser, $dbpw, array(
			PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
			PDO::MYSQL_ATTR_COMPRESS =&gt; true,
			PDO::ATTR_PERSISTENT =&gt; true
			)
		);

	}
	protected function getInstance(){
        return self::$dbh;
    }

}

/* the collectable class implements machinery for Pool::collect */
class Work extends Stackable {
	public function __construct($data) {
		$this-&gt;data = $data;
		#print_r($data);
	}

	public function run() {
		#$this-&gt;worker-&gt;logger-&gt;log("%s executing in Thread #%lu", __CLASS__, $this-&gt;worker-&gt;getThreadId() );

		try {
			$dbh  = $this-&gt;worker-&gt;getInstance();
			#print_r($dbh);
               		$id = $this-&gt;data['id'];
			$mobile = safenet_decrypt($this-&gt;data['mobile']);
			#printf("%d, %s \n", $id, $mobile);
			if(strlen($mobile) &gt; 11){
				$mobile = substr($mobile, -11);
			}
			if($mobile == 'null'){
			#	$sql = "UPDATE members_digest SET mobile = '".$mobile."' where id = '".$id."'";
			#	printf("%s\n",$sql);
			#	$dbh-&gt;query($sql);
				$mobile = '';
				$sql = "UPDATE members_digest SET mobile = :mobile where id = :id";
			}else{
				$sql = "UPDATE members_digest SET mobile = md5(:mobile) where id = :id";
			}
			$sth = $dbh-&gt;prepare($sql);
			$sth-&gt;bindValue(':mobile', $mobile);
			$sth-&gt;bindValue(':id', $id);
			$sth-&gt;execute();
			#echo $sth-&gt;debugDumpParams();
		}
		catch(PDOException $e) {
			$error = sprintf("%s,%s\n", $mobile, $id );
			file_put_contents("mobile_error.log", $error, FILE_APPEND);
		}

		#$dbh = null;
		printf("runtime: %s, %s, %s, %s\n", date('Y-m-d H:i:s'), $this-&gt;worker-&gt;getThreadId() ,$mobile, $id);
		#printf("runtime: %s, %s\n", date('Y-m-d H:i:s'), $this-&gt;number);
	}
}

$pool = new Pool(100, \ExampleWorker::class, []);

#foreach (range(0, 100) as $number) {
#	$pool-&gt;submit(new Work($number));
#}

$dbhost = 'db.example.com';                     // 数据库服务器
$dbuser = 'example.com';                 		// 数据库用户名
$dbpw = 'password';                             // 数据库密码
$dbname = 'example';
$dbh    = new PDO("mysql:host=$dbhost;port=3307;dbname=$dbname", $dbuser, $dbpw, array(
                        PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
                        PDO::MYSQL_ATTR_COMPRESS =&gt; true
                        )
                );
#print_r($dbh);

#$sql = "select id, mobile from members where id &lt; :id";
#$sth = $dbh-&gt;prepare($sql);
#$sth-&gt;bindValue(':id',300);
#$sth-&gt;execute();
#$result = $sth-&gt;fetchAll();
#print_r($result);
#
#$sql = "UPDATE members_digest SET mobile = :mobile where id = :id";
#$sth = $dbh-&gt;prepare($sql);
#$sth-&gt;bindValue(':mobile', 'aa');
#$sth-&gt;bindValue(':id','272');
#echo $sth-&gt;execute();
#echo $sth-&gt;queryString;
#echo $sth-&gt;debugDumpParams();


$sql = "select id, mobile from members order by id asc"; // limit 1000";
$row = $dbh-&gt;query($sql);
while($members = $row-&gt;fetch(PDO::FETCH_ASSOC))
{
        #$order =  $account['order'];
        #printf("%s\n",$order);
        //print_r($members);
        $pool-&gt;submit(new Work($members));
		#unset($account['order']);
}

$pool-&gt;shutdown();

?&gt;

			
			</pre>
		</section>
		<section class="section" id="idp11"><div class="titlepage"><div><div><h3 class="title">8.3. 数据库持久连接</h3></div></div></div>
			
			<p>总的来说 pthreads 仍然处在发展中，仍有一些不足的地方，我们也可以看到pthreads的git在不断改进这个项目</p>
			<p>数据库持久链接很重要，否则每个线程都会开启一次数据库连接，然后关闭，会导致很多链接超时。</p>
			<pre class="programlisting">
			
&lt;?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
    PDO::ATTR_PERSISTENT =&gt; true
));
?&gt;
			
			</pre>
			<p>但有些场景数据库持久链接适得其反，所以根据你的场景选择链接方式</p>
			<pre class="programlisting">
			
&lt;?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
    PDO::ATTR_PERSISTENT =&gt; false
));
?&gt;
			
			</pre>			
			<p>由于现成持续链接数据，有时可能因为数据库或者网络原因导致数据无法连接，程序抛出异常或终止，所以使用单例并不保险。</p>
			<pre class="programlisting">
			
protected function getInstance(){
	return self::$dbh;
}
			
			</pre>
			<p>为单例增加重新连接功能</p>
			<pre class="programlisting">
			
class SenderWorker extends Worker {

	protected $config;
	protected static $dbh;
	protected static $amqp;
	
	public function __construct($config) {
		$this-&gt;config = $config;
		$this-&gt;logger = new Logger();
	}
	public function run() {

	}
	private function connect(){
		try {
			$dbhost = $this-&gt;config['database']['host'];
			$dbport = $this-&gt;config['database']['port'];
			$dbuser = $this-&gt;config['database']['user'];
			$dbpass = $this-&gt;config['database']['password'];
			$dbname = $this-&gt;config['database']['dbname'];

			self::$dbh = new PDO ( "mysql:host=$dbhost;port=$dbport;dbname=$dbname", $dbuser, $dbpass, array (
					PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'',
					PDO::MYSQL_ATTR_COMPRESS =&gt; true
					/*PDO::ATTR_PERSISTENT =&gt; true*/
			) );
			self::$dbh-&gt;setAttribute ( PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING );

		} catch ( PDOException $e ) {
			$this-&gt;logger ( 'Exception worker', $e-&gt;getMessage( ) );
		} catch ( Exception $e ) {
			$this-&gt;logger ( 'Exception worker', $e-&gt;getMessage( ) );
		}
	}
	protected function getInstance() {

		if(!self::$dbh) {
			$this-&gt;connect();
			$this-&gt;logger ( 'Database', sprintf("Connect database %s, %s", $this-&gt;config['database']['dbname'], $this-&gt;getThreadId ()) );
		}else{
			$this-&gt;logger ( 'Database', sprintf("Get instance database %s, %s", $this-&gt;config['database']['dbname'], $this-&gt;getThreadId ()) );
		}
		
		if(self::$dbh){
			return self::$dbh;
		}else{
			$this-&gt;logger ( 'Database', sprintf("Connect database is error %s, %s", $this-&gt;config['database']['dbname'], $this-&gt;getThreadId ()) );
			$this-&gt;logger ( 'Error', sprintf("Worker is shutdown %s", $this-&gt;getThreadId ()) );
			$this-&gt;shutdown();
		}
	}
	
	public function logger($type, $message) {
		$this-&gt;logger-&gt;logger($type, $message);
	}
	
	public function getAmqpInstance(){
		if(!self::$amqp){
			self::$amqp = new AMQPConnection(array(
				'host' 	=&gt; $this-&gt;config['amqp']['host'], 
				'port' 	=&gt; $this-&gt;config['amqp']['port'], 
				'vhost'	=&gt; $this-&gt;config['amqp']['vhost'], 
				'login' =&gt; $this-&gt;config['amqp']['login'], 
				'password' =&gt; $this-&gt;config['amqp']['password']
			));
			$this-&gt;logger ( 'AMQP', sprintf("Connect amqp %s, %s", $this-&gt;config['amqp']['host'], $this-&gt;getThreadId ()) );
		}else{
			$this-&gt;logger ( 'AMQP', sprintf("Get instance amqp %s, %s", $this-&gt;config['amqp']['host'], $this-&gt;getThreadId ()) );
		}	
		return self::$amqp;
	}

}
			
			</pre>
			<p>每次调用 getInstance() 会判断当前数据库是否已经链接，如果链接丢失，将重新链接数据库。</p>
		</section>
		<section class="section" id="idp12"><div class="titlepage"><div><div><h3 class="title">8.4. 涉及数据库更新</h3></div></div></div>
			
			<p>多线程编程中对数据库更新操作需要注意的是，有些场景，你需要控制同一时刻只能有一个线程对数据库做Update, Delete, Insert，否则数据容易出错。</p>
			<p>例如下面的操作，你会发现程序运行完成后数据字段没有任何变化。这是因为线程间相互覆盖对方之前更新的数据。</p>
			<pre class="programlisting">
$sql = "update import set succeed = succeed+1 where status = :status and id = :id";
			</pre>
			<p>解决方法有两种，一种是外部实现排他锁，一种是在数据库内部实现，通过事物处理，解决线程资源争夺，相互覆盖的问题。</p>
			<pre class="programlisting">
			
	private function updateSucceed($task){
		$dbh = $this-&gt;worker-&gt;getInstance();
		$dbh-&gt;beginTransaction();
		$sql = "update import set succeed = succeed+1 where status = :status and id = :id";
		$sth = $dbh-&gt;prepare ( $sql );
		$sth-&gt;bindValue ( ':id', $task-&gt;id );
		$sth-&gt;bindValue ( ':status', 'Processing' );
		$status = $sth-&gt;execute ();
		$dbh-&gt;commit();
		return $status;
	}
			
			</pre>
		</section>
	</section>
	<section class="section" id="zero"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9. Thread And ZeroMQ</h2></div></div></div>
		
		<p>应用场景，我使用触发器监控数据库某个表，一旦发现有改变就通知程序处理数据</p>
		<section class="section" id="idp13"><div class="titlepage"><div><div><h3 class="title">9.1. 数据库端</h3></div></div></div>
			
			<p>首先安装ZeroMQ 与 ZeroMQ for MySQL UDF 然后创建触发器。 <a class="ulink" href="https://github.com/netkiller/mysql-zmq-plugin" target="_top">https://github.com/netkiller/mysql-zmq-plugin</a></p>
			<pre class="programlisting">
			
CREATE DEFINER=`dba`@`192.168.%` PROCEDURE `Table_Example`(IN `TICKET` INT, IN `LOGIN` INT, IN `CMD` INT, IN `VOLUME` INT)
	LANGUAGE SQL
	NOT DETERMINISTIC
	READS SQL DATA
	SQL SECURITY DEFINER
	COMMENT '交易监控'
BEGIN
	DECLARE Example CHAR(1) DEFAULT 'N';

	IF CMD IN ('0','1') THEN
		IF VOLUME &gt;=10 AND VOLUME &lt;=90 THEN
			select coding into Example from example.members where username = LOGIN and coding = 'Y';
			IF Example = 'Y' THEN
				select zmq_client('tcp://192.168.2.15:5555', CONCAT(TICKET, ',', LOGIN, ',', VOLUME));
			END IF;
		END IF;
	END IF;
END

CREATE DEFINER=`dba`@`192.168.6.20` TRIGGER `Table_AFTER_INSERT` AFTER INSERT ON `MT4_TRADES` FOR EACH ROW BEGIN
	call Table_Example(NEW.TICKET,NEW.LOGIN,NEW.CMD,NEW.VOLUME);
END
			
			</pre>
		</section>
		<section class="section" id="idp14"><div class="titlepage"><div><div><h3 class="title">9.2. 数据处理端</h3></div></div></div>
			
			<pre class="programlisting">
			
&lt;?php
class ExampleWorker extends Worker {

	#public function __construct(Logging $logger) {
	#	$this-&gt;logger = $logger;
	#}

	#protected $logger;
	protected  static $dbh;
	public function __construct() {

	}
	public function run(){
		$dbhost = '192.168.2.1';			// 数据库服务器
		$dbport = 3306;
	    $dbuser = 'www';        			// 数据库用户名
        $dbpass = 'password';             	// 数据库密码
		$dbname = 'example';				// 数据库名

		self::$dbh  = new PDO("mysql:host=$dbhost;port=$dbport;dbname=$dbname", $dbuser, $dbpass, array(
			/* PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\'', */
			PDO::MYSQL_ATTR_COMPRESS =&gt; true,
			PDO::ATTR_PERSISTENT =&gt; true
			)
		);

	}
	protected function getInstance(){
        return self::$dbh;
    }

}

/* the collectable class implements machinery for Pool::collect */
class Fee extends Stackable {
	public function __construct($msg) {
		$trades = explode(",", $msg);
		$this-&gt;data = $trades;
		print_r($trades);
	}

	public function run() {
		#$this-&gt;worker-&gt;logger-&gt;log("%s executing in Thread #%lu", __CLASS__, $this-&gt;worker-&gt;getThreadId() );

		try {
			$dbh  = $this-&gt;worker-&gt;getInstance();

			$insert = "INSERT INTO coding_fee(ticket, login, volume, `status`) VALUES(:ticket, :login, :volume,'N')";
			$sth = $dbh-&gt;prepare($insert);
			$sth-&gt;bindValue(':ticket', $this-&gt;data[0]);
			$sth-&gt;bindValue(':login', $this-&gt;data[1]);
			$sth-&gt;bindValue(':volume', $this-&gt;data[2]);
			$sth-&gt;execute();
			//$sth = null;
			//$dbh = null;

			/* 业务实现在此处 */

			$update = "UPDATE coding_fee SET `status` = 'Y' WHERE ticket = :ticket and `status` = 'N'";
			$sth = $dbh-&gt;prepare($update);
			$sth-&gt;bindValue(':ticket', $this-&gt;data[0]);
			$sth-&gt;execute();
			//echo $sth-&gt;queryString;
		}
		catch(PDOException $e) {
			$error = sprintf("%s,%s\n", $mobile, $id );
			file_put_contents("mobile_error.log", $error, FILE_APPEND);
		}

		#$dbh = null;
		//printf("runtime: %s, %s, %s, %s\n", date('Y-m-d H:i:s'), $this-&gt;worker-&gt;getThreadId() ,$mobile, $id);
		#printf("runtime: %s, %s\n", date('Y-m-d H:i:s'), $this-&gt;number);
	}
}

class Example {
	/* config */
	const LISTEN = "tcp://192.168.2.15:5555";
	const MAXCONN = 100;
	const pidfile = __CLASS__;
	const uid	= 80;
	const gid	= 80;

	protected $pool = NULL;
	protected $zmq = NULL;
	public function __construct() {
		$this-&gt;pidfile = '/var/run/'.self::pidfile.'.pid';
	}
	private function daemon(){
		if (file_exists($this-&gt;pidfile)) {
			echo "The file $this-&gt;pidfile exists.\n";
			exit();
		}

		$pid = pcntl_fork();
		if ($pid == -1) {
			 die('could not fork');
		} else if ($pid) {
			 // we are the parent
			 //pcntl_wait($status); //Protect against Zombie children
			exit($pid);
		} else {
			// we are the child
			file_put_contents($this-&gt;pidfile, getmypid());
			posix_setuid(self::uid);
			posix_setgid(self::gid);
			return(getmypid());
		}
	}
	private function start(){
		$pid = $this-&gt;daemon();
		$this-&gt;pool = new Pool(self::MAXCONN, \ExampleWorker::class, []);
		$this-&gt;zmq = new ZMQSocket(new ZMQContext(), ZMQ::SOCKET_REP);
		$this-&gt;zmq-&gt;bind(self::LISTEN);

		/* Loop receiving and echoing back */
		while ($message = $this-&gt;zmq-&gt;recv()) {
			if($message){
					$this-&gt;pool-&gt;submit(new Fee($message));
					$this-&gt;zmq-&gt;send('TRUE');
			}else{
					$this-&gt;zmq-&gt;send('FALSE');
			}
		}
		$pool-&gt;shutdown();
	}
	private function stop(){

		if (file_exists($this-&gt;pidfile)) {
			$pid = file_get_contents($this-&gt;pidfile);
			posix_kill($pid, 9);
			unlink($this-&gt;pidfile);
		}
	}
	private function help($proc){
		printf("%s start | stop | help \n", $proc);
	}
	public function main($argv){
		if(count($argv) &lt; 2){
			printf("please input help parameter\n");
			exit();
		}
		if($argv[1] === 'stop'){
			$this-&gt;stop();
		}else if($argv[1] === 'start'){
			$this-&gt;start();
		}else{
			$this-&gt;help($argv[0]);
		}
	}
}

$example = new Example();
$example-&gt;main($argv);
			
			</pre>
			<p>使用方法</p>
			<pre class="screen">
# php example.php start
# php example.php stop
# php example.php help
			</pre>
			<p>此程序涉及守候进程实现$this-&gt;daemon()运行后转到后台运行，进程ID保存，进程的互斥（不允许同时启动两个进程），线程池连接数以及线程任务等等</p>
		</section>
	</section>
	<section class="section" id="idp15"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10. 延伸阅读</h2></div></div></div>
		
		<p><a class="ulink" href="http://netkiller.github.io/journal/php.mq.html" target="_top">PHP高级编程之消息队列</a></p>
		<p><a class="ulink" href="http://netkiller.github.io/journal/php.daemon.html" target="_top">PHP高级编程之守护进程</a></p>
	</section>
</section><div xmlns="" id="disqus_thread"/><script xmlns="">

var disqus_config = function () {
this.page.url = "http://www.netkiller.cn";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'netkiller'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//netkiller.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script><noscript xmlns="">Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><br xmlns=""/><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"/></body></html>