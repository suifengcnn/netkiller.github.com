<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>实操 Web Cache</title><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="/journal/journal.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><meta name="description" content="写这篇文章的原因，是我看到网上很多谈这类的文章，多是人云亦云，不求实事，误导读者。 下面文中我会一个一个做实验，并展示给你，说明为什么会这样。只有自己亲自尝试才能拿出有说服力的真凭实据。 2014-03-12 首次发布 2015-08-27 修改，增加特殊数据缓存"/><meta name="keywords" content="If-Modified-Since, Last-Modified, ETag, If-None-Match, "/></head><body><section xml:lang="zh-cn" class="article" id="idp1"><div class="titlepage"><div><div><h2 class="title">实操 Web Cache</h2></div><div><h3 class="subtitle"><em>http://netkiller.github.io/journal/cache.html</em></h3></div><div><div class="author"><h3 class="author"><span class="honorific">Mr</span>. <span class="firstname">Neo Chen</span> <span class="surname">(陈景峯)</span>, <span class="lineage">netkiller, BG7NYT</span></h3><div class="affiliation">
			<div class="address"><p><br/>
				<span class="country">中国</span><span class="state">广东省</span><span class="city">深圳市</span><span class="street">龙华新区民治街道溪山美地</span><br/>
				<span class="postcode">518131</span><br/>
				<span class="phone">+86 13113668890</span><br/>
				<br/>
				<code class="email">&lt;<a class="email" href="mailto:netkiller@msn.com">netkiller@msn.com</a>&gt;</code><br/>
			</p></div>
		</div></div></div><div><p class="releaseinfo">$Id: 12dfba037a04a025e01285ca3d35a1192d9bb95d </p></div><div><div class="legalnotice" id="legalnotice">
	<p class="legalnotice-title"><strong>版权声明</strong></p>
	<p>转载请与作者联系，转载时请务必标明文章原始出处和作者信息及本声明。</p>
	<table style="border: 0; " class="simplelist"><tr><td>
		<a class="ulink" href="http://creativecommons.org/licenses/by/3.0/" target="_top">
			<div><table style="border: 0; width: 180px; cellpadding: 0; cellspacing: 0;"><tr><td><img src="/images/by-nc-sa.png" width="180"/></td></tr></table></div>
		</a>
		</td><td>
			<table style="border: 0; " class="simplelist"><tr><td>
					文档出处:
				</td></tr><tr><td>
					<a class="ulink" href="http://netkiller.github.io/" target="_top">http://netkiller.github.io</a>
				</td></tr><tr><td>
					<a class="ulink" href="http://netkiller.sourceforge.net/" target="_top">http://netkiller.sourceforge.net</a>
				</td></tr></table>
		</td><td>
			<a class="ulink" href="/images/weixin.jpg" target="_top"><div><table style="border: 0; width: 80px; cellpadding: 0; cellspacing: 0;"><tr><td><img src="/images/weixin.jpg" width="80"/></td></tr></table></div></a>
		</td><td>
			<p>微信扫描二维码进入 Netkiller 微信订阅号 </p>
			<p>QQ群：128659835 请注明“读者”</p>
		</td></tr></table>
	<p/>
</div></div><div><p class="pubdate">2017-06-16</p></div><div><div class="abstract"><div class="abstract-title">摘要</div>
			<p>写这篇文章的原因，是我看到网上很多谈这类的文章，多是人云亦云，不求实事，误导读者。</p>
			<p>下面文中我会一个一个做实验，并展示给你，说明为什么会这样。只有自己亲自尝试才能拿出有说服力的真凭实据。</p>
			<p>2014-03-12 首次发布</p>
			<p>2015-08-27 修改，增加特殊数据缓存</p>
		</div></div></div><hr/></div><div class="toc"><div class="toc-title">目录</div><ul class="toc"><li><span class="section"><a href="#idp2">1. 测试环境</a></span></li><li><span class="section"><a href="#modified">2. 文件修改日期 If-Modified-Since / Last-Modified</a></span><ul><li><span class="section"><a href="#idp4">2.1. 静态文件</a></span><ul><li><span class="section"><a href="#idp3">2.1.1. if_modified_since</a></span></li></ul></li><li><span class="section"><a href="#idp5">2.2. 通过rewrite伪静态处理</a></span></li><li><span class="section"><a href="#idp6">2.3. 动态文件</a></span></li></ul></li><li><span class="section"><a href="#etag">3. ETag / If-None-Match</a></span><ul><li><span class="section"><a href="#idp7">3.1. 静态文件</a></span></li><li><span class="section"><a href="#idp8">3.2. 动态程序</a></span></li></ul></li><li><span class="section"><a href="#expires">4. Expires / Cache-Control</a></span><ul><li><span class="section"><a href="#idp9">4.1. 静态文件</a></span></li><li><span class="section"><a href="#idp10">4.2. 动态文件</a></span></li></ul></li><li><span class="section"><a href="#fastcgi">5. FastCGI 缓存相关</a></span></li><li><span class="section"><a href="#meta">6. HTML META 与 Cache</a></span></li><li><span class="section"><a href="#gzip">7. gzip</a></span><ul><li><span class="section"><a href="#idp11">7.1. gzip 总结</a></span></li></ul></li><li><span class="section"><a href="#proxy">8. 反向代理与缓存</a></span><ul><li><span class="section"><a href="#proxy.gzip">8.1. gzip 处理</a></span></li></ul></li><li><span class="section"><a href="#data">9. 特殊数据缓存</a></span><ul><li><span class="section"><a href="#idp12">9.1. json</a></span></li><li><span class="section"><a href="#idp13">9.2. XML</a></span></li></ul></li><li><span class="section"><a href="#summary">10. 总结</a></span></li></ul></div>
	
	<section class="section" id="idp2"><div class="titlepage"><div><div><h2 class="title" style="clear: both">1. 测试环境</h2></div></div></div>
		
		<p>CentOS 6.5</p>
		<p>Nginx安装脚本 https://github.com/oscm/shell/blob/master/nginx/nginx.sh</p>
		<p>php安装脚本 https://github.com/oscm/shell/blob/master/php/5.5.8.sh</p>
	</section>
 	<section class="section" id="modified"><div class="titlepage"><div><div><h2 class="title" style="clear: both">2. 文件修改日期 If-Modified-Since / Last-Modified</h2></div></div></div>
 		
 		<p>If-Modified-Since 小于 Last-Modified 返回 HTTP/1.1 200 OK, 否则返回 HTTP/1.0 304 Not Modified</p>
		<p>每次浏览器请求文件会携带  If-Modified-Since 头，将当前时间发送给服务器，与服务器的Last-Modified时间对对比，如果大于Last-Modified时间，返回HTTP/1.0 304 Not Modified不会重新打开文件，否则重新读取文件并返回内容</p>
 		<section class="section" id="idp4"><div class="titlepage"><div><div><h3 class="title">2.1. 静态文件</h3></div></div></div>
			
			<p>nginx/1.0.15 静态文件自动产生 Last-Modified 头</p>
			<pre class="screen">
# nginx -v
nginx version: nginx/1.0.15

# curl -I http://192.168.6.9/index.html
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 07:36:03 GMT
Content-Type: text/html
Content-Length: 6
Last-Modified: Thu, 27 Feb 2014 07:29:50 GMT
Connection: keep-alive
Accept-Ranges: bytes
			</pre>
			<p>图片文件</p>
			<pre class="screen">
# curl -I http://192.168.6.9/image.png
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 07:37:18 GMT
Content-Type: image/png
Content-Length: 41516
Last-Modified: Thu, 27 Feb 2014 07:36:59 GMT
Connection: keep-alive
Accept-Ranges: bytes
			</pre>

			<div class="tip"><h3 class="title">提示</h3>
			<p>疑问 nginx/1.4.5 默认没有 Last-Modified</p>
				<pre class="screen">
# nginx -v
nginx version: nginx/1.4.5

# curl -I http://192.168.2.15/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:13:44 GMT
Content-Type: text/html
Connection: keep-alive
				</pre>
				<p>经过一番周折最终找到答案 Nginx 如果开启 ssi 会禁用Last-Modified 关闭 ssi 后输出如下</p>
				<pre class="screen">
# curl -I  http://localhost/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 05:44:29 GMT
Content-Type: text/html
Content-Length: 6
Last-Modified: Wed, 25 Dec 2013 03:18:16 GMT
Connection: keep-alive
ETag: "52ba4e78-6"
Accept-Ranges: bytes
				</pre>
				<p/>
			</div>

			<p>再测试一次</p>
			<pre class="screen">
# curl -H "If-Modified-Since: Fir, 28 Feb 2014 07:42:55 GMT" -I http://192.168.2.15/test.html
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:34:54 GMT
Last-Modified: Fri, 28 Feb 2014 01:55:50 GMT
Connection: keep-alive
ETag: "530feca6-8b"
			</pre>
			<p>测试结果成功返回 HTTP/1.1 304 Not Modified， 但又莫名其妙的出现了 ETag。 这就是Nignx本版差异，非常混乱。</p>
			<p>既然出现了ETag我们也顺便测试一下</p>
			<pre class="screen">
# curl -H 'If-None-Match: "530feca6-8b"' -I http://192.168.2.15/test.html
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:39:18 GMT
Last-Modified: Fri, 28 Feb 2014 01:55:50 GMT
Connection: keep-alive
ETag: "530feca6-8b"
			</pre>
			<p>也是成功的</p>

			<p>测试图片</p>
			<pre class="screen">
# curl -I http://localhost/logo.jpg
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:59:04 GMT
Content-Type: image/jpeg
Content-Length: 10103
Last-Modified: Fri, 28 Feb 2014 02:56:37 GMT
Connection: keep-alive
ETag: "530ffae5-2777"
Accept-Ranges: bytes


# curl -H 'If-None-Match: "530ffae5-2777"' -I http://localhost/logo.jpg
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 03:03:33 GMT
Last-Modified: Fri, 28 Feb 2014 02:56:37 GMT
Connection: keep-alive
ETag: "530ffae5-2777"

# curl -H "If-Modified-Since: Fri, 28 Feb 2014 12:04:18 GMT" -I http://localhost/logo.jpg
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 03:04:45 GMT
Content-Type: image/jpeg
Content-Length: 10103
Last-Modified: Fri, 28 Feb 2014 02:56:37 GMT
Connection: keep-alive
ETag: "530ffae5-2777"
Accept-Ranges: bytes
			</pre>
			<p>测试结果，ETag通过测试，If-Modified-Since无论如何也无法返回 304 可能还需要其他的HTTP头，浏览器测试都通过返回 HTTP/1.1 304 Not Modified</p>

			<p>现在换成浏览器测试 Chrome Firefox成功， 因为浏览器不会主动发送If-Modified-Since, 浏览器只有发现Last-Modified后，第二次请求才会推送 If-Modified-Since 需要刷新两次页面。</p>

			<section class="section" id="idp3"><div class="titlepage"><div><div><h4 class="title">2.1.1. if_modified_since</h4></div></div></div>
				
				<p>在开启ssi的情况下，通过参数 if_modified_since 可以开启 Last-Modified</p>
				<pre class="screen">
server {
    listen       80;
    server_name  192.168.2.15;
    if_modified_since before;
}
				</pre>

				<p>测试结果看不到 Last-Modified, 因为 Nginx 的 if_modified_since before;参数只有接收到浏览器发过来的If-Modified-Since头才会发送Last-Modified</p>

				<pre class="screen">
# curl -I http://192.168.2.15/test.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:39:42 GMT
Content-Type: text/html
Connection: keep-alive
				</pre>
				<p>最终 if_modified_since before; 数没有起到作用</p>

				<p>参数设置为 if_modified_since exact;</p>
				<pre class="screen">
# curl -I http://192.168.2.15/test.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:45:40 GMT
Content-Type: text/html
Connection: keep-alive

# curl -H 'If-None-Match: "530feca6-8b"' -I http://192.168.2.15/test.html
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:45:44 GMT
Last-Modified: Fri, 28 Feb 2014 01:55:50 GMT
Connection: keep-alive
ETag: "530feca6-8b"

# curl -H "If-Modified-Since: Fir, 28 Feb 2014 07:42:55 GMT" -I http://192.168.2.15/test.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 02:45:50 GMT
Content-Type: text/html
Connection: keep-alive
				</pre>
				<p>测试失败，浏览器也是实测失败，ETag却成功</p>
			</section>
		</section>

		<section class="section" id="idp5"><div class="titlepage"><div><div><h3 class="title">2.2. 通过rewrite伪静态处理</h3></div></div></div>
			
			<p>index.php仍然是上面的那个php文件，我们只是做了伪静态</p>
			<pre class="screen">
			
location / {
        root   /www;
        index  index.html index.htm;
		rewrite ^/test.html$ /index.php last;
}
			
			</pre>
			<p>现在我们分别通过curl有chrome/firefox进行测试</p>

			<pre class="screen">
			
# curl -H "If-Modified-Since: Fri, 28 Feb 2014 08:42:55 GMT" -I  http://192.168.6.9/test.html
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 08:55:19 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Thu, 26 Feb 2014 08:39:35 GMT
			
			</pre>
			<p>经过测试无论是 curl 还是 chrome/firefox 均无法返回304.</p>
			<p>下面是我的分析，仅供参考。用户请求index.html Nginx 会找到该文件读取 mtime 与 If-Modified-Since 匹配，如果If-Modified-Since大于 Last-Modified返回 304否则返回200.</p>
			<p>为什么同样操作经过伪静态的test.html就不行呢？ 我分析当用户请求test.html Nginx 首先做Rewrite处理，然后跳转到index.php 整个过程nginx 并没有访问实际物理文件test.html也就没有mtime, 所以Nginx 返回200.</p>
			<p>如果 Nginx 按预想的返回304，nginx 需要读取程序返回的HTTP头，Nginx 并没有这样的处理逻辑。</p>
		</section>

		<section class="section" id="idp6"><div class="titlepage"><div><div><h3 class="title">2.3. 动态文件</h3></div></div></div>
			
			<p>动态文件没有 Last-Modified 头，我们可以伪造一个</p>
			<pre class="screen">
			
# curl -I http://192.168.6.9/index.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 07:57:59 GMT
Content-Type: text/html
Connection: keep-alive
			
			</pre>
			<p>在程序中加入HTTP头推送操作,Last-Modified时间是27号，当前时间是28号，我们要让Last-Modified 小于当前时间才行。</p>
			<pre class="screen">
			
# cat index.php
&lt;?php
header('Last-Modified: Thu, 27 Feb 2014 08:39:35 GMT' );
//header('Last-Modified: ' .gmdate('D, d M Y H:i:s') . ' GMT' );
?&gt;
Hello
			
			</pre>
			<p>现在你将看到 Last-Modified</p>
			<pre class="screen">
			
# curl -I http://localhost/modified.php
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 05:59:28 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 10:04:18 GMT
			
			</pre>
			<div class="note"><h3 class="title">注意</h3>
				
				<p>虽然我们让动态程序返回了 Last-Modified ，但浏览器不认，经过测试 Chrome / Firefox 均不会承认.php文件，并缓存其内容。</p>
				<pre class="screen">
				
# curl -I http://localhost/modified.php
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 05:59:28 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 10:04:18 GMT

# curl -H "If-Modified-Since: Fri, 28 Feb 2014 08:42:55 GMT" -I  http://localhost/modified.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Fri, 28 Feb 2014 05:32:30 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Thu, 26 Feb 2014 08:39:35 GMT
				
				</pre>
				<p>Last-Modified 对动态程序来说没有起到实际作用</p>
			</div>

			<p>Last-Modified是程序产生的，Nginx无法读到，让程序去处理状态返回是可行的，下面我们修改程序如下。</p>
			<pre class="screen">
			
# cat modified.php
&lt;?php
$mtime = 'Fri, 28 Feb 2014 12:04:18 GMT';
cache($mtime);
function cache($mtime)
{
	$http_if_modified_since = null;
	if(array_key_exists ('HTTP_IF_MODIFIED_SINCE',$_SERVER)){
		$http_if_modified_since = $_SERVER['HTTP_IF_MODIFIED_SINCE'];
	}
	echo $http_if_modified_since;
	if ($http_if_modified_since &gt;= $mtime)
	{
		header('Last-Modified: '.$mtime, true, 304);
		exit;
	} else {
		header('Last-Modified: ' . $mtime );
	}

}
print_r($_SERVER);
echo date("Y-m-d H:i:s");
?&gt;
			
			</pre>
			<p>测试效果</p>
			<pre class="screen">
			
# curl -I http://localhost/modified.php
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 05:22:28 GMT
Content-Type: text/html
Connection: keep-alive
			
			</pre>
			<p>伪造一个 If-Modified-Since 日期小于我们指定的日期程序返回HTTP/1.1 200 OK</p>
			<pre class="screen">
			
# curl -H "If-Modified-Since: Fri, 28 Feb 2014 10:04:18 GMT" -I http://localhost/modified.php
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 05:22:13 GMT
Content-Type: text/html
Connection: keep-alive
			
			</pre>
			<p>伪造一个 If-Modified-Since 日期大于我们指定的日期程序返回HTTP/1.1 304 Not Modified</p>
			<pre class="screen">
			
# curl -H "If-Modified-Since: Fri, 28 Feb 2014 20:04:18 GMT" -I http://localhost/modified.php
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 05:21:31 GMT
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 12:04:18 GMT
			
			</pre>
			<p>测试成功，并且在浏览器端也测试成功 HTTP/1.1 304 Not Modified</p>
			<p>将modified.php伪静态处理 </p>
			<pre class="screen">
    location / {
        root   /www;
        index  index.html index.htm;
		rewrite ^/modified.html$ /modified.php last;
    }
			</pre>
			<p>测试</p>
			<pre class="screen">
# curl -I http://localhost/modified.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 06:21:10 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 10:04:18 GMT

# curl -H "If-Modified-Since: Fri, 28 Feb 2014 12:04:18 GMT" -I http://localhost/modified.html
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 06:21:22 GMT
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 10:04:18 GMT
			</pre>
			<p>达到预期效果</p>
		</section>
	</section>

	<section class="section" id="etag"><div class="titlepage"><div><div><h2 class="title" style="clear: both">3. ETag / If-None-Match</h2></div></div></div>
		
		<p>上面的Last-Modified测试中发现ETag虽然不限制，但是暗中还是可用的：）</p>
		<p>etag on; 开启Nginx etag支持，lighttpd 默认开启</p>
		<pre class="screen">
		
server {
    listen       80;
    server_name phalcon;

    charset utf-8;

    access_log  /var/log/nginx/host.access.log  main;
	etag on;
    location / {
        root   /www/phalcon/public;
        index  index.html index.php;
    }
}
		
		</pre>
		<p>检查ETag输出</p>
		<pre class="screen">
# curl -I http://localhost/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 03:08:28 GMT
Content-Type: text/html
Connection: keep-alive

# curl -I http://phalcon/img/css.png
HTTP/1.1 200 OK
Server: nginx
Date: Thu, 27 Feb 2014 09:20:49 GMT
Content-Type: image/png
Content-Length: 1133
Last-Modified: Fri, 14 Feb 2014 08:05:03 GMT
Connection: keep-alive
ETag: "52fdce2f-46d"
Accept-Ranges: bytes3
		</pre>
		<p>即使你开启了 ETag Nginx 对 HTML、CSS文件也不做处理。最终在一个外国网站是找到一个nginx-static-etags模块，有兴趣自己尝试，这里就不讲了。</p>
		<section class="section" id="idp7"><div class="titlepage"><div><div><h3 class="title">3.1. 静态文件</h3></div></div></div>
			
			<p>首先查询etag值</p>
			<pre class="screen">
# curl -I http://phalcon/img/css.png
HTTP/1.1 200 OK
Server: nginx
Date: Thu, 27 Feb 2014 09:25:41 GMT
Content-Type: image/png
Content-Length: 1133
Last-Modified: Fri, 14 Feb 2014 08:05:03 GMT
Connection: keep-alive
ETag: "52fdce2f-46d"
Accept-Ranges: bytes
			</pre>
			<p>然后向服务器发送If-None-Match HTTP头</p>
			<pre class="screen">
# curl -H 'If-None-Match: "52fdce2f-46d"' -I http://phalcon/img/css.png
HTTP/1.1 304 Not Modified
Server: nginx
Date: Thu, 27 Feb 2014 09:25:44 GMT
Last-Modified: Fri, 14 Feb 2014 08:05:03 GMT
Connection: keep-alive
ETag: "52fdce2f-46d"
			</pre>
			<p>这次比较顺利，成功返回HTTP/1.1 304 Not Modified</p>
		</section>
		<section class="section" id="idp8"><div class="titlepage"><div><div><h3 class="title">3.2. 动态程序</h3></div></div></div>
			
			<p>默认情况输出如下</p>
			<pre class="screen">
# curl -I http://192.168.6.9/index.php
HTTP/1.1 200 OK
Server: nginx
Date: Thu, 27 Feb 2014 09:29:13 GMT
Content-Type: text/html; charset=utf-8
Connection: keep-alive
			</pre>
			<p>测试程序</p>
			<pre class="screen">
			
&lt;?php
header('Last-Modified: Thu, 26 Feb 2014 08:39:35 GMT' );
header('Etag: "abcdefg"');
#header('Last-Modified: ' .gmdate('D, d M Y H:i:s') . ' GMT' );
?&gt;
Hello
			
			</pre>
			<p>测试效果</p>
			<pre class="screen">
# curl -I http://192.168.6.9/index.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 09:41:06 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Thu, 26 Feb 2014 08:39:35 GMT
Etag: "abcdefg"

[root@centos6 ~]# curl -H 'If-None-Match: "abcdefg"' -I http://192.168.6.9/index.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 09:41:42 GMT
Content-Type: text/html
Connection: keep-alive
Last-Modified: Thu, 26 Feb 2014 08:39:35 GMT
Etag: "abcdefg"
			</pre>
			<p>测试情况与之前的Last-Modified结果一样</p>
			<p>动态程序返回Etag真的就没有用了吗？</p>
			<p>答案是：非也， 有一个方法可以让动态程序返回的 Etag 也能发挥作用，程序修改如下</p>
			<pre class="screen">
			
&lt;?php
$etag = md5('http://netkiller.github.io');
cache($etag);
function cache($etag)
{
        $http_if_none_match = null;
        if(array_key_exists ('HTTP_IF_NONE_MATCH',$_SERVER)){
                $http_if_none_match = $_SERVER['HTTP_IF_NONE_MATCH'];
        }

        if ($http_if_none_match == $etag)
        {
                header('Etag: '.$etag, true, 304);
                exit;
        } else {
                header('Etag: '.$etag);
        }

}
print_r($_SERVER);
echo date("Y-m-d H:i:s");
?&gt;
			
			</pre>
			<p>首先查看Etag值</p>
			<pre class="screen">
# curl  -I http://192.168.6.9/test.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 10:07:19 GMT
Content-Type: text/html
Connection: keep-alive
Etag: 7467675324d0f7a3e01ce5151848fedb
			</pre>
			<p>发送If-None-Match头</p>
			<pre class="screen">
# curl -H 'If-None-Match: 7467675324d0f7a3e01ce5151848fedb' -I http://192.168.6.9/test.php
HTTP/1.1 304 Not Modified
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 10:07:39 GMT
Connection: keep-alive
Etag: 7467675324d0f7a3e01ce5151848fedb
			</pre>
			<p>达成预计效果，此种方法同样可以用于 Last-Modified，伪静态后效果更好</p>
			<p>Etag 值的运算技巧，我习惯上采用URL同时配合伪静态例如</p>
			<pre class="screen">
$etag = $_SERVER['REQUEST_URI']
			</pre>
			<p>URL类似 http://www.example.com/news/100/1000.html 一次请求便缓存页面，这样带来一个更新的问题，于是又做了这样的处理</p>
			<pre class="screen">
http://www.example.com/news/100/1000.1.html
			</pre>
			<p>.1.是版本号，每次修改后+1操作，.1.没有人格意义rewrite操作是会丢弃这个参数，仅仅是为了始终有新的URL对应内容</p>
		</section>
	</section>
	<section class="section" id="expires"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4. Expires / Cache-Control</h2></div></div></div>
		
		<p>前面所讲 Last-Modified 与 Etag 主要用于分辨文件是否修改过， 无法控制页面在浏览器端缓存的时间。Expires / Cache-Control 可以控制缓存的时间段</p>
		<p>Expires 是 HTTP/1.0标准，Cache-Control是 HTTP/1.1标准。都能正常工作，HTTP/1.1规范中max-age优先级高于Expires,有些浏览器会联动设置，例如你设置了Cache-Control随之自动生成Expires，仅仅为了兼容。</p>
		<section class="section" id="idp9"><div class="titlepage"><div><div><h3 class="title">4.1. 静态文件</h3></div></div></div>
			
			<p>首先配置nginx设置html与png文件缓存1天</p>
			<pre class="screen">
location ~ .*\.(html|png)$
{
    expires      1d;
}
			</pre>
			<p>当前情况</p>
			<pre class="screen">
# curl -I http://192.168.6.9/index.html
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 10:47:08 GMT
Content-Type: text/html
Content-Length: 6
Last-Modified: Thu, 27 Feb 2014 07:29:50 GMT
Connection: keep-alive
Accept-Ranges: bytes
			</pre>
			<p>重启Nginx后的HTTP协议头多出Expires与Cache-Control</p>
			<pre class="screen">
# curl -I http://192.168.6.9/index.html
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 10:42:09 GMT
Content-Type: text/html
Content-Length: 3698
Last-Modified: Fri, 26 Apr 2013 20:36:51 GMT
Connection: keep-alive
Expires: Fri, 28 Feb 2014 10:42:09 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes
			</pre>
		</section>
		<section class="section" id="idp10"><div class="titlepage"><div><div><h3 class="title">4.2. 动态文件</h3></div></div></div>
			
			<p>默认返回</p>
			<pre class="screen">
# curl -I http://192.168.6.9/index.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 11:45:05 GMT
Content-Type: text/html
Connection: keep-alive
			</pre>
			<p>index.php 增加 Cache-Control 输出控制</p>
			<pre class="screen">
			
header('Cache-Control: max-age=259200');
			
			</pre>
			<p>再次查看</p>
			<pre class="screen">
# curl -I http://192.168.6.9/index.php
HTTP/1.1 200 OK
Server: nginx/1.0.15
Date: Thu, 27 Feb 2014 11:53:48 GMT
Content-Type: text/html
Connection: keep-alive
Cache-Control: max-age=259200
			</pre>
			<p>现在使用 Chrome 、Firefox 测试，你会发现始终返回200，并且max-age=259200数值不会改变。</p>
			<p>原因是Cache-Control程序输出的，Nginx并不知道，所以Nginx 不会给你返回304</p>
			<pre class="screen">
			
header('Last-Modified: ' .gmdate('D, d M Y H:i:s') . ' GMT' );

$offset = 60 * 60 * 24;
header('Expires: ' . gmdate('D, d M Y H:i:s', time() + $offset) . ' GMT');

$ttl=3600;
header("Cache-Control: max-age=$ttl, must-revalidate");
			
			</pre>
			<p>这种方法不能实现缓存的目的</p>
		</section>
	</section>
	<section class="section" id="fastcgi"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5. FastCGI 缓存相关</h2></div></div></div>
		
		<p>我们做个尝试将 expires 1d;加到location ~ \.php$中，看看能不能实现缓存的目的。</p>
		<pre class="screen">
    location ~ \.php$ {
        root           /www;
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /www$fastcgi_script_name;
        include        fastcgi_params;
		expires      1d;
    }
		</pre>
		<p>测试程序</p>
		<pre class="screen">
		
# cat expires.php
&lt;?php
echo date("Y-m-d H:i:s");
?&gt;
		
		</pre>
		<p>测试结果</p>
		<pre class="screen">
# curl -I http://localhost/expires.php
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 04:39:57 GMT
Content-Type: text/html
Connection: keep-alive
Expires: Sat, 01 Mar 2014 04:39:57 GMT
Cache-Control: max-age=86400
		</pre>
		<p>虽然推送 Cache-Control: max-age=86400 但是 IE Chrome Firefox 仍不能缓存页面</p>
	</section>
	<section class="section" id="meta"><div class="titlepage"><div><div><h2 class="title" style="clear: both">6. HTML META 与 Cache</h2></div></div></div>
		
		<p>创建一个测试文件如下</p>
		<pre class="screen">
		
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Hello&lt;/title&gt;
	&lt;meta http-equiv="Cache-Control" content="max-age=7200" /&gt;
	&lt;meta http-equiv="expires" content="Fri, 28 Feb 2014 12:04:18 GMT" /&gt;
&lt;/head&gt;
&lt;body&gt;
	Helloworld
&lt;/body&gt;
&lt;/html&gt;
		
		</pre>
		<p>测试HTML页面</p>
		<pre class="screen">
		
# curl -i http://localhost/test.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 03:30:45 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive

&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Hello&lt;/title&gt;
	&lt;meta http-equiv="Cache-Control" content="max-age=7200" /&gt;
	&lt;meta http-equiv="expires" content="Fri, 28 Feb 2014 12:04:18 GMT" /&gt;
&lt;/head&gt;
&lt;body&gt;
	Helloworld
&lt;/body&gt;
&lt;/html&gt;
		
		</pre>
		<p>我们可以看到HTML页面中meta设置缓存对Nginx并不起作用, 很多人会说对浏览器起作用！</p>
		<p>这次我测试了 IE11, Chrome, Firefox 发现都无法缓存页面，可能对IE5什么的还有用，我没有环境测试，因为10年前我们在B/S开发经常这样使用</p>
		<pre class="screen">
		
&lt;meta http-equiv="cache-control" content="max-age=0" /&gt;
&lt;meta http-equiv="cache-control" content="no-cache" /&gt;
&lt;meta http-equiv="expires" content="0" /&gt;
&lt;meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" /&gt;
&lt;meta http-equiv="pragma" content="no-cache" /&gt;
		
		</pre>
		<p>至少在当年IE是认这些Meta的，进入HTML5时代很多都发生了变化，所以不能一概而论</p>
	</section>
	<section class="section" id="gzip"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7. gzip</h2></div></div></div>
		
		<p>defalte 是 Apache httpd 的标准这里只谈gzip</p>
		<p>首先创建一个 gzip.html</p>
		<pre class="screen">
# curl -I http://localhost/gzip.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Mon, 03 Mar 2014 01:49:45 GMT
Content-Type: text/html
Content-Length: 19644
Last-Modified: Mon, 03 Mar 2014 01:49:02 GMT
Connection: keep-alive
ETag: "5313df8e-4cbc"
Accept-Ranges: bytes
		</pre>
		<p>开启 gzip on;</p>
		<pre class="screen">
server {
    listen       80;
    server_name  localhost;

    #charset utf-8;
    #access_log  /var/log/nginx/log/host.access.log  main;
    #etag on;
    #ssi on;
    gzip on;
		</pre>
		<p>现在看看效果</p>
		<pre class="screen">
# curl -I http://localhost/gzip.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Mon, 03 Mar 2014 01:51:56 GMT
Content-Type: text/html
Content-Length: 19644
Last-Modified: Mon, 03 Mar 2014 01:49:02 GMT
Connection: keep-alive
ETag: "5313df8e-4cbc"
Accept-Ranges: bytes
		</pre>
		<p>并没有什么不同，现在增加HTTP头Accept-Encoding:gzip,defalte看看</p>
		<pre class="screen">
		
# curl -H Accept-Encoding:gzip,defalte  http://localhost/gzip.html
		
		</pre>
		<p>如果你能看到非文本内容（俗称乱码）就表示成功了。输入内容就是gzip压缩后二进制数据，我们使用gunzip可以解压缩</p>
		<pre class="screen">
# curl -H Accept-Encoding:gzip,defalte  http://localhost/gzip.html | gunzip
		</pre>
		<p>如果能正常看到html输出，表示压缩无误。</p>
		<section class="section" id="idp11"><div class="titlepage"><div><div><h3 class="title">7.1. gzip 总结</h3></div></div></div>
			
			<p>gzip on; 开启后默认支持 text/html 不能在 gzip_types 再次定义，否则会提示重复MIME类型</p>
			<pre class="screen">
Starting nginx: nginx: [warn] duplicate MIME type "text/html" in /etc/nginx/conf.d/localhost.conf:16
			</pre>
			<p>高级配置参考</p>
			<pre class="screen">
    gzip  on;
    gzip_http_version 1.0;
    gzip_types        text/plain text/xml text/css application/xml application/xhtml+xml application/rss+xml application/atom_xml application/javascript application/x-javascript application/json;
    gzip_disable      "MSIE [1-6]\.";
    gzip_disable      "Mozilla/4";
    gzip_comp_level   6;
    gzip_proxied      any;
    gzip_vary         on;
    gzip_buffers      4 8k;
    gzip_min_length   1000;		
			</pre>
		</section>
	</section>
	<section class="section" id="proxy"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8. 反向代理与缓存</h2></div></div></div>
		
		<p>反向代理服务器缓存方式分为：</p>
		<p>强制缓存，指定文件，扩展名，URL设置缓存时间</p>
 		<p>遵循HTTP协议头标准进行缓存</p>
		<p>默认配置，只进行代理，不进行缓存</p>
 		<pre class="screen">
server {
    listen       80;
    server_name  192.168.2.15;
    #access_log  /var/log/nginx/log/host.access.log  main;

	location / {
	  proxy_pass        http://localhost:80;
	  proxy_set_header  X-Real-IP  $remote_addr;
	}
}
 		</pre>
 		<p>反向代理会产生两条日志（access_log 写入一个文件中，如果分开写，则会分开写入日志）</p>
 		<pre class="screen">
192.168.2.15 - - [28/Feb/2014:18:09:33 +0800] "HEAD /modified.html HTTP/1.1" 200 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
127.0.0.1 - - [28/Feb/2014:18:09:33 +0800] "HEAD /modified.html HTTP/1.0" 200 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
		</pre>
		<p>Last-Modified 与 ETag 会透传过去</p>
		<pre class="screen">
# curl -H "If-Modified-Since: Fri, 28 Feb 2014 12:04:18 GMT" -I http://192.168.2.15/modified.html
HTTP/1.1 304 Not Modified
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 10:17:30 GMT
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 10:04:18 GMT
		</pre>
		<p>我们可以看到两条日志都返回304</p>
		<pre class="screen">
192.168.2.15 - - [28/Feb/2014:18:17:30 +0800] "HEAD /modified.html HTTP/1.1" 304 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
127.0.0.1 - - [28/Feb/2014:18:17:30 +0800] "HEAD /modified.html HTTP/1.0" 304 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
		</pre>
		<p>下面为反向代理增加缓存功能</p>
		<pre class="screen">
proxy_temp_path   /tmp/proxy_temp_dir;
proxy_cache_path  /tmp/proxy_cache_dir  levels=1:2   keys_zone=nginx_cache:200m inactive=3d max_size=30g;

server {
    listen       80;
    server_name  192.168.2.15;

	location / {
		proxy_cache nginx_cache;
		proxy_cache_key $host$uri$is_args$args;
		proxy_set_header  X-Real-IP  $remote_addr;
		proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
		proxy_cache_valid 200 10m;
		proxy_pass        http://localhost;
	}

	location ~ .*\.(php|jsp|cgi)?$
	{
	     proxy_set_header Host  $host;
	     proxy_set_header X-Forwarded-For  $remote_addr;
	     proxy_pass http://backend_server;
	}
}
		</pre>
		<p/>
		<pre class="screen">
# curl  -I http://192.168.2.15/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 10:57:35 GMT
Content-Type: text/html
Content-Length: 12
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 06:54:45 GMT
ETag: "531032b5-c"
Expires: Sat, 01 Mar 2014 10:57:35 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes

# curl  -I http://192.168.2.15/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 10:57:41 GMT
Content-Type: text/html
Content-Length: 12
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 06:54:45 GMT
ETag: "531032b5-c"
Expires: Sat, 01 Mar 2014 10:57:35 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes

# curl  -I http://192.168.2.15/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Fri, 28 Feb 2014 10:57:46 GMT
Content-Type: text/html
Content-Length: 12
Connection: keep-alive
Last-Modified: Fri, 28 Feb 2014 06:54:45 GMT
ETag: "531032b5-c"
Expires: Sat, 01 Mar 2014 10:57:35 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes
		</pre>
		<p>上面共请求了3次服务器</p>
		<pre class="screen">
192.168.2.15 - - [28/Feb/2014:18:57:35 +0800] "HEAD /index.html HTTP/1.1" 200 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
127.0.0.1 - - [28/Feb/2014:18:57:35 +0800] "GET /index.html HTTP/1.0" 200 12 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "192.168.2.15"
192.168.2.15 - - [28/Feb/2014:18:57:41 +0800] "HEAD /index.html HTTP/1.1" 200 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
192.168.2.15 - - [28/Feb/2014:18:57:46 +0800] "HEAD /index.html HTTP/1.1" 200 0 "-" "curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.14.0.0 zlib/1.2.3 libidn/1.18 libssh2/1.4.2" "-"
		</pre>
		<p>第一次连接192.168.2.15然后转发给127.0.0.1 返回 HTTP/1.1 200 OK</p>
		<p>后面两次连接192.168.2.15没有转发给127.0.0.1 直接返回 HTTP/1.1 200 OK</p>
		<p>查看缓存目录,我们可以看到生成的缓存文件</p>
		<pre class="screen">
# find /tmp/proxy_*
/tmp/proxy_cache_dir
/tmp/proxy_cache_dir/1
/tmp/proxy_cache_dir/1/79
/tmp/proxy_cache_dir/1/79/b47a0009c531900de2a15ba80c0e3791
/tmp/proxy_temp_dir
		</pre>
		
		<section class="section" id="proxy.gzip"><div class="titlepage"><div><div><h3 class="title">8.1. gzip 处理</h3></div></div></div>
			
			<p>http://localhost/gzip.html 是支持压缩的，192.168.2.15 proxy_pass http://localhost</p>
			<pre class="screen">
# curl -H Accept-Encoding:gzip,defalte  http://localhost/gzip.html			
			</pre>
			<p>运行后输出乱码</p>
			<pre class="screen">
# curl -H Accept-Encoding:gzip,defalte  http://192.168.2.15/gzip.html
			</pre>
			<p>现在透过反向代理请求试试，你会发现gzip压缩无效，输出的是HTML，这是怎么回事呢？这是因为反向代理不清楚后面的服务器是否支持gzip，所以一律按照正常html请求。现在我们开启 gzip_vary on; 每次返回数据会携带Vary: Accept-Encoding 头。</p>
			<pre class="screen">
	gzip  on;
	gzip_vary on;
			</pre>
			<p>reload nginx 后查看Vary: Accept-Encoding输出</p>
			<pre class="screen">
# curl -I http://localhost/gzip.html
HTTP/1.1 200 OK
Server: nginx/1.4.5
Date: Mon, 03 Mar 2014 02:09:16 GMT
Content-Type: text/html
Content-Length: 19644
Last-Modified: Mon, 03 Mar 2014 01:49:02 GMT
Connection: keep-alive
Vary: Accept-Encoding
ETag: "5313df8e-4cbc"
Accept-Ranges: bytes
			</pre>
			<p>有 Vary: Accept-Encoding 头，现在再测试一次</p>
			<pre class="screen">
			
# curl -H "Accept-Encoding: gzip" http://192.168.2.15/gzip.html
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Hello&lt;/title&gt;
			
			</pre>
			<p>测试失败，并没有出现预期效果，于是到网站找答案，中文与英文资料都看个遍，没有解决.</p>
			<p>最后只能让反向代理取到数据后再压缩一次，配置开启 gzip on;</p>
			<pre class="screen">
proxy_temp_path   /tmp/proxy_temp_dir;
proxy_cache_path  /tmp/proxy_cache_dir  levels=1:2   keys_zone=nginx_cache:200m inactive=3d max_size=30g;

server {
    listen       80;
    server_name  192.168.2.15;

	gzip on;
	
	location / {
		proxy_set_header X-Real-IP  $remote_addr;
		proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for; 
		# proxy_set_header Accept-Encoding "gzip"; 没有任何效果
		proxy_pass       http://localhost;
	}
}
			</pre>
			<p>Nginx 反向代理作为代理绰绰有余，如果做缓存服务器，还是使用squid, varnish吧。</p>
		</section>
	</section>
	<section class="section" id="data"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9. 特殊数据缓存</h2></div></div></div>
		
		<p>缓存并非只能缓存静态内容，HTML,CSS,JS以及图片意外的数据一样可以缓存。</p>
		<p>只要处理好HTTP头即可。例如Ajax动态内容缓存，JSON数据缓存。</p>
		<section class="section" id="idp12"><div class="titlepage"><div><div><h3 class="title">9.1. json</h3></div></div></div>
			
			<p>当用户请求json地址时，我们将 json 数据附加HTTP头（Cache-Control, Expires, ETag），然后返回给用户，用户的设备会遵循HTTP的声明，进行缓存操作。</p>
			<pre class="screen">
curl -I http://api.example.com/article/json/2/20/0.html
HTTP/1.1 200 OK
Expires: Wed, 26 Aug 2015 05:40:57 GMT
Date: Wed, 26 Aug 2015 05:39:57 GMT
Server: nginx
Content-Type: application/json; charset=utf-8
Transfer-Encoding: chunked
Cache-Control: max-age=60
ETag: 4238111283
Age: 69475
X-Via: 1.1 kaifeng45:3 (Cdn Cache Server V2.0)
Connection: keep-alive
			</pre>
			<p>注意这里使用了伪静态 /article/json/2/20/0.html 伪静态与缓存没有关系，实际起作用的是HTTP头。</p>
			<p>我们可以看到 Content-Type: application/json; charset=utf-8 声明，表明这是json数据，而不是HTML。</p>
			<p>现在我们来演示一下JSON被缓存的效果，首先要说明 http://api.example.com/article/json/2/20/0.html 不是0.html文件，而是采用phalcon框架开发的一个程序，article是控制器类名称，json是jsonAction方法, 2/20/0 是传递给jsonAction的参数。</p>
			<pre class="screen">
$ curl -I http://api.example.com/article/json/2/20/0.html
HTTP/1.1 200 OK
Expires: Thu, 27 Aug 2015 05:24:21 GMT
Date: Thu, 27 Aug 2015 05:23:21 GMT
Server: nginx/1.5.7
Content-Type: application/json; charset=utf-8
Transfer-Encoding: chunked
Cache-Control: max-age=60
ETag: 558918903
Age: 1
X-Via: 1.1 kaifeng45:3 (Cdn Cache Server V2.0)
Connection: keep-alive
			</pre>
			<p>上面第一次请求数据将被缓存。我们第二次请求推送 HTTP 头 If-None-Match。</p>
			<pre class="screen">
$ curl -H 'If-None-Match: 558918903' -I http://api.example.com/article/json/2/20/0.html
HTTP/1.0 304 Not Modified
Date: Thu, 27 Aug 2015 05:23:22 GMT
Content-Type: application/json; charset=utf-8
Expires: Thu, 27 Aug 2015 05:24:22 GMT
ETag: 558918903
Cache-Control: max-age=60
Age: 15
X-Via: 1.0 kaifeng45:3 (Cdn Cache Server V2.0)
Connection: keep-alive			
			</pre>
			<p>数据被缓存并返回结果 HTTP/1.0 304 Not Modified，304代码是告诉用户端该页面或者数据没有变动，无需要再次下载数据。</p>
		</section>
		<section class="section" id="idp13"><div class="titlepage"><div><div><h3 class="title">9.2. XML</h3></div></div></div>
			
			<p>这里是指动态生成的XML，处理方式与 JSON一样，XML数据附加HTTP头（Cache-Control, Expires, ETag）后返回给用户。</p>
		</section>
	</section>
	<section class="section" id="summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10. 总结</h2></div></div></div>
		
		<p>经过详细的测试我们发现不同的浏览器，不同的Web服务器，甚至每个版本都有所差异。</p>
		<p>测试总结 Apache HTTPD 最完善 Lighttpd 其次， Nignx仍在快速发展中，Nignx每个版本差异很大，对HTTP协议实现标准也不太严谨，因为Nignx在大陆是趋势，所以下面给出的例子都是nginx</p>
		<p>我比较看好Lighttpd，FastCGI 部分我一般是用php-fpm替代Lighttpd的spawn-fcgi</p>
		<p>切记使用Nginx要注意每个本版细微变化，否则升级后会有影响。我习惯使用yum 安装 nginx 随时 yum update 升级。</p>
		<p>另外FastCGI 与 mod_php也有所区别</p>
		<p>延伸阅读《	Netkiller Web 手札》<a class="ulink" href="http://netkiller.github.io/www/index.html" target="_top">http://netkiller.github.io/www/index.html</a></p>
	</section>
</section><div xmlns="" id="disqus_thread"/><script xmlns="">

var disqus_config = function () {
this.page.url = "http://www.netkiller.cn";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'netkiller'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//netkiller.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script><noscript xmlns="">Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><br xmlns=""/><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"/></body></html>